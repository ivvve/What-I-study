# 냄새와 휴리스틱

### 주석

- C1: 부적절한 정보
다른 시스템(VCS, Bug Tracking System, Issue Tracker...)에 저장할 정보는 주석으로 적절하지 못하다.
주석은 **코드와 설계에 기술적인 설명을 부연하는 수단**이다.

- C2: 쓸모 없는 주석
쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋다.
쓸모 없어진 주석은 재빨리 삭제하는 편이 가장 좋다.
코드를 그릇된 방향으로 이끈다.

- C3: 중복된 주석
코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다.

```js
i++; // i 증가
```

```java
// IDE에서 생성하는 template만 그대로 둔 javadoc
/**
  * 
  * @param year
  * @return
  */
public isLeapYear(final int year) {}
```

주석은 코드만으로 다하지 못하는 설명을 추가로 알려준다.

- C4: 성의 없는 주석
작성할 가치가 있는 주석은 잘 작성할 가치도 있다.
주석을 달려면 시간을 들여 최대한 멋지게 작성한다.
**간결하고 명료하게** 작성한다.

- C5: 주석 처리된 코드
주석 처리된 코드는 그 자리에 남아 매일매일 낡아간다.
더 이상 존재하지 않는 함수를 호출하거나 이름이 바뀐 변수를 사용하는 등 주석 처리된 코드는 주변에 변화를 따라가지 않는다.

주석 처리된 코드는 즉각 지워버려라!

### 환경

### 함수

### 일반

### 자바

- J1: 긴 import 목록을 피하고 와일드카드를 사용하라
패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져와라.

```java
// bad
import package.foo;
import package.bar;
import package.foobar;

// good
import package.*;
```

때론 와일드카드 import문은 이름 충돌이나 모호성을 초래한다.
이름이 같으나 패키지가 다른 클래스는 명시적인 import나 package 경로를 명시한다.
다소 번거로우나 자주 발생하지 않기에 여전히 와일드카드 import문이 더 낫다.

- J2: 상수는 상속히지 않는다.
```java
public interface PayrollConstants {
  public static final int TENTHS_PER_WEEK = 400;
  public static final double OVERTIME_RATE = 1.5;
}
```

```java
public abstract class Employee implements PayrollConstants {
  public abstract Money calculatePay();
}
```

```java
public class HourlyEmployee extends Employee {
  private int tenthsWorked;
  private double hourlyRate;

  public Money calculatePay() {
    final int straightTime = Math.min(this.tenthsWorked, TENTHS_PER_WEEK);
    final int overTime = this.tenthsWorked - straightTime;

    return new Money(
      this.hourlyRate * (this.tenthsWorked + OVERTIME_RATE * overTime)
    );
  }
}
```

상수를 상속을 받아서 사용한다.
상속은 이렇게 사용하면 안된다!
`PayrollConstants`와 `Employee`가 **IS-A** 관계가 성립하지도 않는다.

상속하지 말고 import해서 사용하도록 한다.

- J3: 상수 vs Enum
int와 같은 상수는 코드에서 의미를 잃어버리기도 한다.
반면 **enum**은 이름이 부여된 enumeration에 속하기 때문에 의미를 잃지 않는다.

의미도 잘 부여하면서도 메서드와 필드도 사용할 수 있기 때문에 상수보다 훨씬 더 유연하고 서울적인 강력한 도구이다.

### 이름

- N1: 서술적인 이름을 사용하라
이름을 성급하게 정하지 않는다.
서술적인 이름을 신중하게 고른다.

소프트웨어의 가독성의 **90%**는 이름이 결정한다.
그러므로 시간을 들여 현명한 이름을 선택하고 유효한 상태로 유지한다.

```java
// bad
public int x() {
  int q = 0;
  int z = 0;

  for (int kk = 0; kk < 10; kk++) {

    if (l[z] == 10) {
      q += (10 + l[z + 1] + l[z + 2]);
      z += 1;
    } else if (l[z] + l[z + 1] == 10) {
      q += (10 + l[z + 2]);
      z += 2;
    } else {
      q += (l[z] + l[z + 1]);
      z += 2;
    }
  }

  return q;
}
```

```java
// good
public int x() {
  int score = 0;
  int frame = 0;

  for (int frameNumber = 0; frameNumber < 10; frameNumber++) {
    
    if (isStrike(frame)) { // 상세 구현은 알 수 없지만 의미를 충분히 짐작할 수 있다.
      score += (10 + nextTwoBallsForStrike(frame));
      frame += 1;
    } else if (isSpare(frame)) {
      score += (10 + nextBallForSpare(frame));
      frame += 2;
    } else {
      score += twoBallsInFrame(frame);
      frame += 2;
    }
  }

  return q;
}
```

신중라게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.

- N2: 적잘한 추상화 수준에서 이름을 선택하라
구현을 드러내는 이름을 피하라.
추상화 수준을 반영하는 이름을 선택하라.

```java
public interface Modem {
  boolean dial(final String phoneNumber); // 적절한가??
  boolean disconnect();
  boolean send(final char c);
  char recv();
  String getConnectedPhoneNumber(); // 적절한가??
}
```

전화선에 연결되지 않는 일부 모뎀의 경우를 생각해보라.
그렇다면 **전화번호**라는 개념은 확실히 추상화 수준이 틀렸다.

```java
public interface Modem {
  boolean connect(final String connectionLocator);
  boolean disconnect();
  boolean send(final char c);
  char recv();
  String getConnectedLocator();
}
```

위 `Modem`은 전화번호는 물론이고 다른 연결 방식에도 사용 가능하다.

- N3: 가능하다면 표준 명명법을 사용하라
기본의 명명법을 사용하는 이름은 이해하기 더 쉽다.
예를 들어 **Decorator Pattern**을 활용한다면 클래스 이름에 Decorator라는 단어를 사용해야 한다.

디자인 패턴은 한 가지 표준에 불과하다.
예를 들어 Java에서 객체를 문자열로 변환할 때 `toString()`이라는 이름을 많이 쓴다.
이런 이름은 기존의 관례를 따르는 편이 좋다.

특정 프로젝트 내에서는 팀마다 적용할 표준을 고안한다.
프로젝트 내에서 사용하는 `Ubiquitous Language`를 사용하여 독자들이 코드를 이해하기 쉽게 하라.

- N4: 명확한 이름
함수나 변수의 목절을 명확히 밝히는 이름을 선택한다.

```java
private String doRename() {
  if (refactorReferences) {
    renameReferences();
  }

  renamePage();
  pathToRename.removeNameFromEnd();
  pathToRename.addNameToEnd(newName);
  return PathParser.render(pathToRename);
}
```

`doRename`이라는 이름만 봐서는 메서드의 역할이 분명하지 않다.
내부에 `renamePage`라는 메서드가 있어 그 역할이 더더욱 모호해진다.

`renamePageAndOptionallyAllReferences`라는 이름이 더 좋다.

- N6: 인코딩을 피하라
이름에 유형 정보나 범위 정보를 넣어서는 안 된다.
`m_`이나 `f`와 같은 접두어는 불필요하다.

- N7: 이름으로 부수 효과를 설명하라
이름에 부수효과를 숨기지 않는다.

```java
public ObjectOutputStream getOos() throws IOException {
  if (m_oos == null) {
    m_oos = new ObjectOutputStream(m_socket.getOutputStream());
  }

  return m_oos;
}
```

단순히 `ObjectOutputStream`를 가져오는 것이 아니라 없으면 새로 생성한 뒤 가져온다.
그러므로 `createOrReturnOos`라는 이름이 더 좋다.

### 테스트

- T1: 불충분한 테스트
테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.
테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

- T2: 커버리지 도구를 사용하라
커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.

---

#### Test Coverage 측정

![](./images/17_01.png)

![](./images/17_02.png)

[Coverage Report example](./test_coverage_example/index.html)

---

- T3: 사소한 테스트를 건너뛰지 마라
사소한 테스트는 짜기 쉽지만 이것이 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.

- T4: 무시한 테스트는 모호함을 뜻한다
때론 요구사항이 불분명하여 프로그램이 돌아가는 방식을 확신하기 어렵다.
불문명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 `@Ignore`를 붙여 표현한다.

- T5: 경계 조건을 테스트하라
경계 조건은 각별히 신경 써서 테스트한다.

```js
// bad
descript('isLegallyAdult function', () => {
  descript('when age is 8', () => {
    const age = 8;

    it('returns false', () => {
      expect(isLegallyAdult(age)).toBe(false);
    });
  });

  descript('when age is 30', () => {
    const age = 30;

    it('returns true', () => {
      expect(isLegallyAdult(age)).toBe(true);
    });
  });
});
```

```js
// good
descript('isLegallyAdult function', () => {
  descript('when age is 18', () => {
    const age = 18;

    it('returns false', () => {
      expect(isLegallyAdult(age)).toBe(false);
    });
  });

  descript('when age is 19', () => {
    const age = 19;

    it('returns true', () => {
      expect(isLegallyAdult(age)).toBe(true);
    });
  });
});
```

- T6: 버그 주변은 철저히 테스트하라
버그는 서로 모이는 경향이 있다.
한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.

- T7: 실패 패턴을 살펴라
때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.
합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

e.g.) 입력이 5자를 넘기는 테스트가 모두 실패할 경우, 음수를 파라미터로 받는 함수의 테스트가 모두 실패할 경우

- T8: 테스트 커버리지 패턴을 살펴라
통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

- T9: 테스트는 빨라야 한다
느린 테스트 케이스는 실행하지 않게 된다.
그러므로 테스트 케이스가 빨리 돌아가게 노력한다.
